# Генерация лабиринта и поиск пути от точки А до точки Б

## Описание проекта

Этот проект предоставляет реализацию генерации лабиринта и поиска пути от точки А до точки Б. Основные возможности
включают
генерацию
лабиринтов с использованием алгоритмов Краскала и Прима, генерацию случайных препятствий и монет, а также алгоритм
поиска пути
между заданными начальной и конечной точками с помощью алгоритмов A* (A-star) и BFS.

## Структура проекта

- `constants/` — Пакет для хранения различных констант и настроек.
- `enums/` — Пакет, содержащий перечисления для типов клеток (`Type`), типов местности (`TerrainType`).
- `interfaces/` - Пакет, содержащий интерфейсы для генерации лабиринта, поиска пути и их рендеринга.
- `records/` - Пакет, представляющий координаты лабиринта.
- `models/` — Пакет с основными моделями и структурами данных.
    - `Maze` — Класс, представляющий лабиринт с его размерами и клетками.
    - `Cell` — Класс, представляющий отдельную ячейку лабиринта, с типами (стена, проход) и характеристиками (тип
      местности).
- `generators/` — Пакет, содержащий алгоритмы для генерации лабиринта.
    - `KruskalMazeGenerator` — Класс для генерации лабиринта с использованием алгоритма Краскала.
    - `PrimMazeGenerator` — Класс для генерации лабиринта с использованием алгоритма Прима.
    - `ObstaclesGenerator` — Класс для добавления случайных препятствий и монет на карте лабиринта.
- `solvers/` — Пакет, содержащий алгоритмы поиска пути в лабиринте.
    - `AStarSolver` — Класс для поиска пути в лабиринте с использованием алгоритма A* (A-star).
    - `BFSSolver` — Класс для поиска пути в лабиринте с использованием алгоритма BFS.
- `settings/` — Пакет для взаимодействия с пользователем при вводе параметров лабиринта.
    - `MazeDimensionInput` — Класс для ввода размеров лабиринта (высота, ширина).
    - `MazeCoordinateInput` — Класс для ввода начальных и конечных координат лабиринта.
    - `GeneratorSelector` — Класс для выбора алгоритма генерации лабиринта (Краскал или Прим).
    - `SolverSelector` — Класс для выбора алгоритма поиска пути (A* (A-star) или BFS).
    - `MazeSettings` — Класс для запуска игры.
- `view/` — Пакет, содержащий реализацию отображения лабиринта и найденного пути.
    - `ConsoleRender` — Класс для отображения лабиринта и найденного пути.
- `pictures/` — Пакет, содержащий скриншоты примеров отображения лабиринта и найденного пути от точки А до точки Б.

## Алгоритмы генерации лабиринта

### Алгоритм Краскала (Kruskal's Algorithm)

Алгоритм Краскала используется для генерации лабиринта путем создания минимального остовного дерева (МОТ) на основе
графа, представляющего лабиринт.

#### Шаги алгоритма:

1. **Инициализация**: Создать лабиринт, где каждая ячейка изначально является стеной.
2. **Формирование рёбер**: Добавить рёбра между соседними ячейками (с шагом в две клетки) в список рёбер.
3. **Перемешивание рёбер**: Перемешать список рёбер для случайного порядка обработки.
4. **Объединение компонент**:
    - Для каждого ребра, если оно соединяет две разные компоненты (проверяется с использованием структуры данных для
      непересекающихся множеств), открыть проход между ними и объединить компоненты.
    - Открывать путь как между выбранными клетками, так и между промежуточными.
5. **Дополнительные пути**: Случайным образом создаются дополнительные проходы для разнообразия маршрутов.
6. **Добавление препятствий и монет**: Случайным образом создаются препятствия (песок, болото) и монеты в лабиринте.
7. **Установка стартовой и конечной точки**: Ячейки старта и финиша устанавливаются как проходы.

### Алгоритм Прима (Prim's Algorithm)

Алгоритм Прима генерирует лабиринт, начиная с одной случайной клетки и постепенно добавляя проходы, чтобы соединить
ячейки, пока не будут созданы все пути.

#### Шаги алгоритма:

1. **Инициализация**: Лабиринт создается с полным заполнением стен.
2. **Выбор начальной ячейки**: Ячейка лабиринта, которую указал пользователь во время ввода, определяется как начальная
   точка.
3. **Проход по соседям**:
    - Устанавливается начальная ячейка как проход, и все ее допустимые соседи добавляются в список для обработки.
    - Для каждой ячейки из списка, если она еще является стеной, она становится проходом, соединенным с одним из уже
      доступных проходов, после чего все ее допустимые соседи добавляются в список.
4. **Создание тупиков**: Ячейки с одним соседом случайным образом закрываются, создавая тупики, которые увеличивают
   сложность лабиринта.
5. **Удаление случайных стен**: Удаляются случайные стены для формирования неидеального лабиринта и возможности
   альтернативных путей.
6. **Добавление препятствий и монет**: Случайным образом создаются препятствия (песок, болото) и монеты в лабиринте.
7. **Установка конечной точки**: Конечная точка также устанавливается как проход.

## Алгоритмы поиска пути

### Алгоритм A* (A-star)

Алгоритм A*, или «Поиск A-звездочка», является эвристическим алгоритмом поиска пути. Он использует комбинацию
фактической стоимости пути от начальной точки (S) и предполагаемой стоимости пути до цели (E), чтобы выбрать оптимальный
маршрут.

#### Шаги алгоритма:

1. **Начальная и конечная точки**:
    - Создается начальная точка (старт) с нулевой стоимостью пути и эвристикой, которая оценивает расстояние до конечной
      точки.
    - Алгоритм продолжает искать до тех пор, пока не достигнет конечной точки или не исчерпает варианты для
      рассмотрения.
2. **Открытое и закрытое множества**:
    - Используется **очередь с приоритетом (PriorityQueue)**, которая сортирует узлы по их полной стоимости
      пути (`fCost = gCost + hCost`), где `gCost` — стоимость пути до текущей точки, а `hCost` — эвристическая оценка
      расстояния до цели.
    - **Открытое множество (openSet)** хранит узлы, которые будут проверяться. **Закрытое множество (closedSet)** хранит
      узлы, которые уже обработаны.
3. **Эвристическая функция**: Алгоритм использует **Манхэттенское расстояние** между текущей и конечной точкой для
   оценки оставшейся стоимости пути.
4. **Расчет стоимости клетки**: Стоимость прохождения клетки зависит от типа поверхности, и определяет дополнительные
   расходы на прохождение, которые добавляются к стоимости пути (`gCost`).
5. **Поиск пути**:
    - Для каждой соседней клетки текущей точки проверяется, улучшит ли путь через нее стоимость пути. Если да, узел
      добавляется в очередь с приоритетом.
    - Как только достигнута конечная точка, алгоритм восстанавливает путь, проходя от конечного узла к начальному.

### Алгоритм поиска в ширину (BFS)

Алгоритм поиска, который проходит все возможные пути одинаковой длины перед переходом к более длинным путям. Он
гарантирует нахождение кратчайшего пути в лабиринте, если все клетки имеют одинаковую стоимость.

#### Шаги алгоритма:

1. **Очередь путей**: Для хранения текущего пути используется очередь `PriorityQueue`, где пути с меньшими затратами
   обрабатываются первыми. Это позволяет BFS находить кратчайший путь с учетом стоимости поверхностей.
2. **Посещенные клетки**: Используется множество `visited`, чтобы избежать обработки клеток более одного раза.
3. **Обход соседей**: Алгоритм проверяет соседние клетки (вверх, вниз, влево, вправо) для каждой текущей позиции. Если
   клетка является проходимой и еще не посещена, она добавляется в очередь.
4. **Расчет стоимости клетки**: Каждая клетка имеет свою стоимость прохождения, которая добавляется к общей стоимости
   пути.

## Запуск проекта

1. Склонируйте репозиторий.
2. Откройте проект в вашей IDE.
3. Скомпилируйте и запустите основной класс Main.

## Сценарий использования

### Общие настройки лабиринта

1. **Ввод высоты лабиринта**: необходимо ввести одно целое число.
2. **Ввод ширины лабиринта**: необходимо ввести одно целое число.
3. **Ввод начальной точки**: необходимо ввести ровно два целых числа через пробел (строка и столбец).
4. **Ввод конечной точки**: необходимо ввести ровно два целых числа через пробел (строка и столбец).

### Выбор алгоритма генерации лабиринта

1. **Алгоритм Прима (Prim's Algorithm)**
2. **Алгоритм Краскала (Kruskal's Algorithm)**

### Выбор алгоритма поиска пути

1. **A\* (A-star)**
2. **Поиск в ширину (BFS)**

### Вывод справочной информации

- Старт: ️🔴
- Финиш: 🟢
- Стена: ⬛
- Проход: ⬜
- Песок: 🟨
- Болото: 🟫
- Монета: 🥮
- Путь: 🐸

### Отображение сгенерированного лабиринта на основе выбранного алгоритма

#### Пример (Краскал):

![Лабиринт](https://github.com/central-university-dev/backend_academy_2024_project_2-java-1zbbxzak1/blob/master/src/main/java/backend/academy/labyrinths/pictures/labyrinth.png)

### Отображение найденного пути от точки А до точки Б на основе выбранного пути

#### Пример (A\* (A-star)):

![Найденный путь](https://github.com/central-university-dev/backend_academy_2024_project_2-java-1zbbxzak1/blob/master/src/main/java/backend/academy/labyrinths/pictures/labyrinth_path.png)
